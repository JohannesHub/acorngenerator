package main

import (
	"fmt"
	"go/types"
	"golang.org/x/tools/go/packages"
	"os"
	"strings"

	. "github.com/dave/jennifer/jen"
)

type qualifiedName struct {
	packageName, typeName string
}

func main() {
	if len(os.Args) != 3 {
		failErr(fmt.Errorf("expected exactly two arguments: <source type> <source interface name>"))
	}

	goPackage := os.Getenv("GOPACKAGE")

	sourceStructName, structObject := getType(os.Args[1])

	structType, ok := structObject.Type().Underlying().(*types.Struct)
	if !ok {
		failErr(fmt.Errorf("type %v is not a struct", structObject))
	}

	err := generate(sourceStructName, structType, os.Args[2], goPackage)
	if err != nil {
		failErr(err)
	}
}

func getType(param string) (string, types.Object) {
	sourceTypePackage, sourceTypeName := splitSourceType(param)

	pkg := loadPackage(sourceTypePackage)

	obj := pkg.Types.Scope().Lookup(sourceTypeName)
	if obj == nil {
		failErr(fmt.Errorf("%s not found in declared types of %s",
			sourceTypeName, pkg))
	}

	if _, ok := obj.(*types.TypeName); !ok {
		failErr(fmt.Errorf("%v is not a named type", obj))
	}
	return sourceTypeName, obj
}

func generate(sourceTypeName string, structType *types.Struct, sourceInterfaceName string, goPackage string) error {
	f := NewFile(goPackage)

	f.PackageComment("Code generated by generator, DO NOT EDIT.")
	f.ImportAlias("github.com/StephanHCB/go-autumn-acorn-registry/api", "auacornapi")
	f.ImportAlias("github.com/StephanHCB/go-autumn-logging-zerolog", "auzerolog")
	f.ImportAlias("github.com/StephanHCB/go-backend-service-common/acorns/repository", "librepo")

	f.Comment("// --- implementing Acorn ---").Line()

	f.Func().Id("New").Params().Qual("github.com/StephanHCB/go-autumn-acorn-registry/api", "Acorn").Block(
		Return(Op("&").Id(sourceTypeName).Values())).Line()

	f.Func().Params(Id("s").Id("*" + sourceTypeName)).Id("Is" + sourceInterfaceName).Params().Bool().Block(
		Return(True())).Line()

	f.Func().Params(Id("s").Id("*" + sourceTypeName)).Id("AcornName").Params().String().Block(
		Return(Qual("bitbucket.interhyp.de/bitbucket/projects/BACKEND/repos/content-maker-smoketest/acorns/service", sourceInterfaceName+"AcornName"))).Line()

	injectedFields := getInjectedFields(structType)
	registryStatements, err := generateRegistryStatements(injectedFields)
	failErr(err)

	f.Func().Params(Id("s").Id("*" + sourceTypeName)).Id("AssembleAcorn").Params(
		Id("registry").Qual("github.com/StephanHCB/go-autumn-acorn-registry/api", "AcornRegistry")).Error().Block(
		registryStatements...).Line()

	setupStatements := generateSetupStatements(injectedFields, sourceInterfaceName)

	f.Func().Params(Id("s").Id("*" + sourceTypeName)).Id("SetupAcorn").Params(
		Id("registry").Qual("github.com/StephanHCB/go-autumn-acorn-registry/api", "AcornRegistry")).Error().Block(
		setupStatements...).Line()

	f.Func().Params(Id("s").Id("*" + sourceTypeName)).Id("TeardownAcorn").Params(
		Id("registry").Qual("github.com/StephanHCB/go-autumn-acorn-registry/api", "AcornRegistry")).Error().Block(
		Return(Nil()))

	return f.Save("acorn.go")
}

func generateSetupStatements(injectedFields []*types.Var, sourceInterfaceName string) []Code {
	setupStatements := generateInjectedFieldsSetup(injectedFields)
	loggingStatement := Id("ctx").Op(":=").
		Qual("github.com/StephanHCB/go-autumn-logging-zerolog", "AddLoggerToCtx").
		Call(Qual("context", "Background").Call()).Line().
		If(Err().Op(":=").Id("s.Setup").Call(Id("ctx")).Op(";").Err().Op("!=").Nil()).Block(
		Id("s").Dot("Logging").Dot("Logger").Call().Dot("Ctx").Call(Id("ctx")).
			Dot("Error").Call().Dot("WithErr").Call(Err()).Dot("Print").
			Call(Id("\"failed to set up business layer " + strings.ToLower(sourceInterfaceName) + ". BAILING OUT\"")).
			Line().Return(Err())).Line().
		Id("s").Dot("Logging").Dot("Logger").Call().Dot("Ctx").Call(Id("ctx")).
		Dot("Info").Call().Dot("Print").Call(Id("\"successfully set up " + strings.ToLower(sourceInterfaceName) + " service\""))
	setupStatements = append(setupStatements, loggingStatement)
	return append(setupStatements, Return(Nil()))
}

func generateInjectedFieldsSetup(injectedFields []*types.Var) []Code {
	var setupStatements = make([]Code, 0)
	if len(injectedFields) == 0 {
		return setupStatements
	}
	setupStatements = append(setupStatements, Var().Err().Error())
	errorHandlingStatement := If(Err().Op("!=").Nil()).Block(Return(Err()))
	for _, field := range injectedFields {
		constructedType, err := constructType(field)
		failErr(err)

		setupAfterStatement := Err().Op("=").Id("registry.SetupAfter").Call(Id("s." + constructedType.typeName).
			Assert(Qual("github.com/StephanHCB/go-autumn-acorn-registry/api", "Acorn")))
		setupStatements = append(setupStatements, setupAfterStatement)
		setupStatements = append(setupStatements, errorHandlingStatement)
	}
	return setupStatements
}

func generateRegistryStatements(injectedFields []*types.Var) ([]Code, error) {
	var registryStatements = make([]Code, 0)
	for _, field := range injectedFields {
		constructedType, err := constructType(field)
		failErr(err)

		statement := Id("s." + field.Name()).Op("=").Id("registry.GetAcornByName").
			Call(Qual(constructedType.packageName, constructedType.typeName+"AcornName")).
			Assert(Qual(constructedType.packageName, constructedType.typeName))
		registryStatements = append(registryStatements, statement)
	}
	registryStatements = append(registryStatements, Return(Nil()))
	return registryStatements, nil
}

func constructType(field *types.Var) (qualifiedName, error) {
	var returnValue qualifiedName

	switch v := field.Type().(type) {
	case *types.Named:
		typeObj := v.Obj()
		returnValue = qualifiedName{packageName: typeObj.Pkg().Path(), typeName: typeObj.Name()}
	default:
		return returnValue, fmt.Errorf("struct field type not hanled: %T", v)
	}
	return returnValue, nil
}

func loadPackage(path string) *packages.Package {
	cfg := &packages.Config{Mode: packages.NeedTypes | packages.NeedImports}
	pkgs, err := packages.Load(cfg, path)
	if err != nil {
		failErr(fmt.Errorf("loading packages for inspection: %v", err))
	}
	if packages.PrintErrors(pkgs) > 0 {
		os.Exit(1)
	}

	return pkgs[0]
}

func splitSourceType(sourceType string) (string, string) {
	idx := strings.LastIndexByte(sourceType, '.')
	if idx == -1 {
		failErr(fmt.Errorf(`expected qualified type as "pkg/path.MyType"`))
	}
	sourceTypePackage := sourceType[0:idx]
	sourceTypeName := sourceType[idx+1:]
	return sourceTypePackage, sourceTypeName
}

func getInjectedFields(structType *types.Struct) []*types.Var {
	var injectedFields = make([]*types.Var, 0)
	for i := 0; i < structType.NumFields(); i++ {
		if strings.Contains(structType.Tag(i), "acorn:\"inject\"") {
			injectedFields = append(injectedFields, structType.Field(i))
		}
	}
	return injectedFields
}

func failErr(err error) {
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
}
